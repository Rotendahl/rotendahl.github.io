{"title":"Overengineering a start page","markdown":{"yaml":{"title":"Overengineering a start page","author":"Benjamin Rotendahl","date":"2023-05-13","date-modified":"2023-05-23","categories":["front-end","code","haskell"],"image":"https://github.com/Rotendahl/Start-Page-Generator/blob/gh-pages/example.png?raw=true","titlegraphic":"https://github.com/Rotendahl/Start-Page-Generator/blob/gh-pages/example.png?raw=true"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n\nThe default start page in my browser of choice (safari) suck. The page looks nice\nbut does not sync between devices, and shows a lot of useless information.\n@fig-safari shows the safari start page. The \"favorites\" section is a copy of\nthe links in my favorites bar, which are already visible in the browser. The\n\"Shared with you\" section is a list of links that my partner has shared with me,\nthey are all old and was never relevant. I don't use the reading list in safari,\nthe entries are all read or added by mistake. The bottom row is the most useful\npart, as it allows me to access tabs from my iPad and iPhone, but the\n[tab group feature in safari][tab-groups] superseeds this feature.\n\n::: {.panel-tabset}\n\n## Bad Safari start page\n\n![Safari's bad startpage](safari.png){#fig-safari}\n\n## Awesome generated start page\n\n![My Generated webpage](https://github.com/Rotendahl/Start-Page-Generator/blob/gh-pages/example.png?raw=true){#fig-generated}\n\n:::\n\n# The solution\n\nI would like my start page to present the configured links in a grid with the\nsame layout on all devices. The links should be static to ensure \"muscle memory\" of\ntheir placement, similar to app placement on my phone home screen. The themeing\nshould switch between light and dark mode depending on the system configuration.\nA design that meets these simple requirements can also be seen in figure @fig-safari.\n\nImplementing this design is can be done with the following html and css:\n\n::: {.panel-tabset}\n\n## HTML\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Start Page</title>\n    <link rel=\"stylesheet\" href=\"variables.css\" />\n    <link rel=\"stylesheet\" href=\"style.css\" />\n  </head>\n\n  <body>\n    <div id=\"container\">\n      <a href=\"https://site-a.com\">\n        <img src=\"https://logo-a.png\" />\n        <p>Site A</p>\n      </a>\n\n      <a href=\"https://site-b.com\">\n        <img src=\"https://logo-b.png\" />\n        <p>Site B</p>\n      </a>\n\n      <a href=\"https://site-c.com\">\n        <img src=\"https://logo-c.png\" />\n        <p>Site C</p>\n      </a>\n    </div>\n  </body>\n</html>\n```\n\n## style.css\n\n<script src=\"https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2FRotendahl%2FStart-Page-Generator%2Fblob%2Fmaster%2Fout%2Fstyle.css&style=github-dark&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on\"></script>\n\n## variables.css\n\n<script src=\"https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2FRotendahl%2FStart-Page-Generator%2Fblob%2Fmaster%2Fout%2Fvariables.css&style=github-dark&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on\"></script>\n\n\n:::\n\nTo make the start page \"responsive\" we add a flexbox to the container div and\nset each link with a fixed max width.  Adding the `flex-wrap: wrap` property\nensures that the links flow nicely to the next row when making it work on phones\nand smaller browser windows as well.\n\n## Configuring the start page\nTo make the above html fit your taste requires:\n\n* Setting your color theme in the `variables.css` file.\n* Adding `<a>` tags with each site you want to include.\n\nThis last point is a bit tedious, but could be done in a few minutes, but that's\nno fun.\n\n# Overengineering the solution\n\nThe above solution of manually adding the `<a>` tags would be the smart way to\nproceed. Instead we are going to overengineer a tool that will do this for us,\nwhile stretching our haskell muscles. We will create a custom data format, a\nparser and a template engine to generate the html above. Lastly we will setup a\nCI/CD pipeline to automatically deploy the start page to github pages.\n\n## Defining the favorite sites grammar.\n\nA favorite site consists of a url, a display name and a logo, the last two are optional.\nWe could have used a format such as json or csv as the configuration file format,\nbut instead we create our own format. @lst-grammar-example shows an example of\nthe format. The idea of the grammar is to have the non optional url in the center\nof a line, if there is a display name it precedes the url and _points_`->`\nto the url defining the favorite. A logo optionally succeeds the url and\n_points_ back `<-` to it.\n\n```{#lst-grammar-example .txt lst-cap=\"Example grammar instance\"}\nsome arbitrary text\n* youtube.com/feed/subscriptions <- <logo-url>\n* Github.com\n* Data Science -> towardsdatascience.com\n* Sentry.io\n* Azure DevOps -> dev.azure.com <- <logo-url>\n```\n\n\n\nA links file can contain two types of text lines: comments and favorites.\nA comment is any line that does not start with a `*` and a favorite is any line\nthat does. A favorite must have a url, but can optionally have a display name and\na logo as specified above. The grammar for the favorite sites file can be seen\nin [BNF][bnf] in @lst-grammar-bnf.\n\n```{#lst-grammar-bnf .txt lst-cap=\"The favorite sites grammar in BNF form\"}\n  favorites ::= * <favorite> \\n <favorites> | ε\n  favorite ::= <display-name> -> <site> | <site>\n  display-name ::= <text>\n  site ::= <url> | <url> <- <url>\n  url ::= <url-spec>\n```\nWhere `<text>` is any string of characters that does not contain `->` or `<-` or\nnewlines and `<url-spec>` is any valid url. The grammar follows the [lexeme][lexeme]\nconvention of parsing, where we allow arbitrary whitespace between tokens, and\ntreat any lines not prefixed with a `*` as whitespace.\n\nThe grammar is non left recursive, non ambiguous requiring no precedence rules,\nthe only downside of the grammar is that it requires lookahead for display names.\nWhen reading the lexeme following a `*` we don't know if it is a display name or\nurl until we observe a `->` or the lack of it. Since the display names are\nshort this will not be a problem in practice[^1].\n\n### Full grammer file\n<script src=\"https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2FRotendahl%2FStart-Page-Generator%2Fblob%2Fmaster%2Flinks.txt&style=github-dark&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on&\"></script>\n\n## Creating the project\nTo setup our haskell project we use [cabal][cabal] and initialize the project with\n```bash\ncabal init\n```\n\nThis will create a [start-page-generator.cabal](https://github.com/Rotendahl/Start-Page-Generator/blob/master/Start-Page-Generator.cabal)\nfile along with _lib_ and _test_ folders.\n\nIn typical haskell fashion we start by creating the types we need for our\nparser/(template engine). The types can be seen below:\n\n<script src=\"https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2FRotendahl%2FStart-Page-Generator%2Fblob%2Fmaster%2Flib%2FSiteTypes.hs&style=github-dark&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on\"></script>\n\nNote that the logo type is a type alias for the url. The `ParsedSite` type\nhas the optional display name and logo url via the maybe monad. Our template\nengine will map between the `ParsedSite` and `Site` types filling in the optional\nfields. For the display name we use the hostname of the url if no display name is\npresent. A missing logo url is filled in with `logo.clearbit.com//<hostname>`\nwhich provides a logo for most sites.\n\n### Testing\nBeing a functional langauge Haskell has many great testing libaries from\nsimple [unit testing][hunit] to [property based testing][quickcheck]. For this\nproject we use the BDD style [hspec][hspec] library. The tests are simple\nassertions that given the specific input the code produces the expected output.\n<script src=\"https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2FRotendahl%2FStart-Page-Generator%2Fblob%2Fmaster%2Ftest%2FTemplateEngineSpec.hs&style=github-dark&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on\"></script>\n\n\n## Parsing the links file\n\nHaskell is excellent for writing parsers, instead of writing clunky regexes that\nare hard to read and maintain we use the parser combinator library: [parsec][parsec].\n\nThe main idea behind parser combinators is that you build a parser for each\npart of the grammar and then combine them to build a parser for the entire grammar.\nFor parsing a site we need to parse a '\\*' character, an optional display name,\nfollowed by an url and an optional logo url.\nThis gives us the parser\n\n```haskell\nparseSite :: Parser ParsedSite\nparseSite = do\n  _ <- string \"*\"\n  whiteSpace\n  name <- optionMaybe $ try parseDisplayName\n  url <- parseUrl\n  logo <- optionMaybe $ try parseLogo\n  return (name, url, logo)\n```\n\nWhich is much easier to read than a regex. See the full parser below.\n\n<script src=\"https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2FRotendahl%2FStart-Page-Generator%2Fblob%2Fmaster%2Flib%2FFavoritesParser.hs&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on\"></script>\n\n## Generating the html\nTo map from the parsed we map from the parsed sites to the site type and replace\nthe template tag in the html with the generated html.\n\n<script src=\"https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2FRotendahl%2FStart-Page-Generator%2Fblob%2Fmaster%2Flib%2FTemplateEngine.hs&style=github-dark&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on\"></script>\n\n\n\n# Deploying the site\nFor deploying static html githubs pages is the obvious choice. Prior to setting\nup a deployment pipeline we first setup a testing pipeline. The testing pipeline\nuses the [Setup haskell](https://github.com/haskell/actions) action which gives\nus a ghc environment. The test pipeline runs the tests and runs the [hlint](https://github.com/ndmitchell/hlint)\nutility which ensures that the code is idiomatic haskell.\n\nFor the deploy pipeline it builds the code, persists the output to a branch called\ngh-pages and deploys the site to github pages. Both pipelines can be found on\n[github](https://github.com/Rotendahl/Start-Page-Generator/tree/master/.github/workflows)\nand the deployed code can be found at [rotendahl.dk/Start-Page-Generator/](https://rotendahl.dk/Start-Page-Generator/)\n\n\n[linksFile]: https://github.com/Rotendahl/StartPageGenerator/blob/master/links.txt\n[tab-groups]: https://support.apple.com/en-gb/guide/safari/ibrwa2d73908/mac\n[favorites]: https://github.com/Rotendahl/Start-Page-Generator/blob/a8a2dced57325b0f0084d7dc009570b501826ee0/links.txt\n[cabal]: https://www.haskell.org/cabal/\n[parsec]: https://hackage.haskell.org/package/parsec\n[bnf]: https://en.wikipedia.org/wiki/Backus–Naur_form\n[lexeme]: https://hackage.haskell.org/package/parsec-3.1.3/docs/Text-Parsec-Token.html#v%3alexeme\n[quickcheck]: https://hackage.haskell.org/package/QuickCheck\n[hunit]: https://hackage.haskell.org/package/HUnit\n[hspec]: https://hspec.github.io/\n\n[^1]: I'm not overengineering my grammer for my overengineered project.\n","srcMarkdownNoYaml":"\n\n# Introduction\n\nThe default start page in my browser of choice (safari) suck. The page looks nice\nbut does not sync between devices, and shows a lot of useless information.\n@fig-safari shows the safari start page. The \"favorites\" section is a copy of\nthe links in my favorites bar, which are already visible in the browser. The\n\"Shared with you\" section is a list of links that my partner has shared with me,\nthey are all old and was never relevant. I don't use the reading list in safari,\nthe entries are all read or added by mistake. The bottom row is the most useful\npart, as it allows me to access tabs from my iPad and iPhone, but the\n[tab group feature in safari][tab-groups] superseeds this feature.\n\n::: {.panel-tabset}\n\n## Bad Safari start page\n\n![Safari's bad startpage](safari.png){#fig-safari}\n\n## Awesome generated start page\n\n![My Generated webpage](https://github.com/Rotendahl/Start-Page-Generator/blob/gh-pages/example.png?raw=true){#fig-generated}\n\n:::\n\n# The solution\n\nI would like my start page to present the configured links in a grid with the\nsame layout on all devices. The links should be static to ensure \"muscle memory\" of\ntheir placement, similar to app placement on my phone home screen. The themeing\nshould switch between light and dark mode depending on the system configuration.\nA design that meets these simple requirements can also be seen in figure @fig-safari.\n\nImplementing this design is can be done with the following html and css:\n\n::: {.panel-tabset}\n\n## HTML\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Start Page</title>\n    <link rel=\"stylesheet\" href=\"variables.css\" />\n    <link rel=\"stylesheet\" href=\"style.css\" />\n  </head>\n\n  <body>\n    <div id=\"container\">\n      <a href=\"https://site-a.com\">\n        <img src=\"https://logo-a.png\" />\n        <p>Site A</p>\n      </a>\n\n      <a href=\"https://site-b.com\">\n        <img src=\"https://logo-b.png\" />\n        <p>Site B</p>\n      </a>\n\n      <a href=\"https://site-c.com\">\n        <img src=\"https://logo-c.png\" />\n        <p>Site C</p>\n      </a>\n    </div>\n  </body>\n</html>\n```\n\n## style.css\n\n<script src=\"https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2FRotendahl%2FStart-Page-Generator%2Fblob%2Fmaster%2Fout%2Fstyle.css&style=github-dark&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on\"></script>\n\n## variables.css\n\n<script src=\"https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2FRotendahl%2FStart-Page-Generator%2Fblob%2Fmaster%2Fout%2Fvariables.css&style=github-dark&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on\"></script>\n\n\n:::\n\nTo make the start page \"responsive\" we add a flexbox to the container div and\nset each link with a fixed max width.  Adding the `flex-wrap: wrap` property\nensures that the links flow nicely to the next row when making it work on phones\nand smaller browser windows as well.\n\n## Configuring the start page\nTo make the above html fit your taste requires:\n\n* Setting your color theme in the `variables.css` file.\n* Adding `<a>` tags with each site you want to include.\n\nThis last point is a bit tedious, but could be done in a few minutes, but that's\nno fun.\n\n# Overengineering the solution\n\nThe above solution of manually adding the `<a>` tags would be the smart way to\nproceed. Instead we are going to overengineer a tool that will do this for us,\nwhile stretching our haskell muscles. We will create a custom data format, a\nparser and a template engine to generate the html above. Lastly we will setup a\nCI/CD pipeline to automatically deploy the start page to github pages.\n\n## Defining the favorite sites grammar.\n\nA favorite site consists of a url, a display name and a logo, the last two are optional.\nWe could have used a format such as json or csv as the configuration file format,\nbut instead we create our own format. @lst-grammar-example shows an example of\nthe format. The idea of the grammar is to have the non optional url in the center\nof a line, if there is a display name it precedes the url and _points_`->`\nto the url defining the favorite. A logo optionally succeeds the url and\n_points_ back `<-` to it.\n\n```{#lst-grammar-example .txt lst-cap=\"Example grammar instance\"}\nsome arbitrary text\n* youtube.com/feed/subscriptions <- <logo-url>\n* Github.com\n* Data Science -> towardsdatascience.com\n* Sentry.io\n* Azure DevOps -> dev.azure.com <- <logo-url>\n```\n\n\n\nA links file can contain two types of text lines: comments and favorites.\nA comment is any line that does not start with a `*` and a favorite is any line\nthat does. A favorite must have a url, but can optionally have a display name and\na logo as specified above. The grammar for the favorite sites file can be seen\nin [BNF][bnf] in @lst-grammar-bnf.\n\n```{#lst-grammar-bnf .txt lst-cap=\"The favorite sites grammar in BNF form\"}\n  favorites ::= * <favorite> \\n <favorites> | ε\n  favorite ::= <display-name> -> <site> | <site>\n  display-name ::= <text>\n  site ::= <url> | <url> <- <url>\n  url ::= <url-spec>\n```\nWhere `<text>` is any string of characters that does not contain `->` or `<-` or\nnewlines and `<url-spec>` is any valid url. The grammar follows the [lexeme][lexeme]\nconvention of parsing, where we allow arbitrary whitespace between tokens, and\ntreat any lines not prefixed with a `*` as whitespace.\n\nThe grammar is non left recursive, non ambiguous requiring no precedence rules,\nthe only downside of the grammar is that it requires lookahead for display names.\nWhen reading the lexeme following a `*` we don't know if it is a display name or\nurl until we observe a `->` or the lack of it. Since the display names are\nshort this will not be a problem in practice[^1].\n\n### Full grammer file\n<script src=\"https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2FRotendahl%2FStart-Page-Generator%2Fblob%2Fmaster%2Flinks.txt&style=github-dark&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on&\"></script>\n\n## Creating the project\nTo setup our haskell project we use [cabal][cabal] and initialize the project with\n```bash\ncabal init\n```\n\nThis will create a [start-page-generator.cabal](https://github.com/Rotendahl/Start-Page-Generator/blob/master/Start-Page-Generator.cabal)\nfile along with _lib_ and _test_ folders.\n\nIn typical haskell fashion we start by creating the types we need for our\nparser/(template engine). The types can be seen below:\n\n<script src=\"https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2FRotendahl%2FStart-Page-Generator%2Fblob%2Fmaster%2Flib%2FSiteTypes.hs&style=github-dark&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on\"></script>\n\nNote that the logo type is a type alias for the url. The `ParsedSite` type\nhas the optional display name and logo url via the maybe monad. Our template\nengine will map between the `ParsedSite` and `Site` types filling in the optional\nfields. For the display name we use the hostname of the url if no display name is\npresent. A missing logo url is filled in with `logo.clearbit.com//<hostname>`\nwhich provides a logo for most sites.\n\n### Testing\nBeing a functional langauge Haskell has many great testing libaries from\nsimple [unit testing][hunit] to [property based testing][quickcheck]. For this\nproject we use the BDD style [hspec][hspec] library. The tests are simple\nassertions that given the specific input the code produces the expected output.\n<script src=\"https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2FRotendahl%2FStart-Page-Generator%2Fblob%2Fmaster%2Ftest%2FTemplateEngineSpec.hs&style=github-dark&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on\"></script>\n\n\n## Parsing the links file\n\nHaskell is excellent for writing parsers, instead of writing clunky regexes that\nare hard to read and maintain we use the parser combinator library: [parsec][parsec].\n\nThe main idea behind parser combinators is that you build a parser for each\npart of the grammar and then combine them to build a parser for the entire grammar.\nFor parsing a site we need to parse a '\\*' character, an optional display name,\nfollowed by an url and an optional logo url.\nThis gives us the parser\n\n```haskell\nparseSite :: Parser ParsedSite\nparseSite = do\n  _ <- string \"*\"\n  whiteSpace\n  name <- optionMaybe $ try parseDisplayName\n  url <- parseUrl\n  logo <- optionMaybe $ try parseLogo\n  return (name, url, logo)\n```\n\nWhich is much easier to read than a regex. See the full parser below.\n\n<script src=\"https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2FRotendahl%2FStart-Page-Generator%2Fblob%2Fmaster%2Flib%2FFavoritesParser.hs&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on\"></script>\n\n## Generating the html\nTo map from the parsed we map from the parsed sites to the site type and replace\nthe template tag in the html with the generated html.\n\n<script src=\"https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2FRotendahl%2FStart-Page-Generator%2Fblob%2Fmaster%2Flib%2FTemplateEngine.hs&style=github-dark&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on\"></script>\n\n\n\n# Deploying the site\nFor deploying static html githubs pages is the obvious choice. Prior to setting\nup a deployment pipeline we first setup a testing pipeline. The testing pipeline\nuses the [Setup haskell](https://github.com/haskell/actions) action which gives\nus a ghc environment. The test pipeline runs the tests and runs the [hlint](https://github.com/ndmitchell/hlint)\nutility which ensures that the code is idiomatic haskell.\n\nFor the deploy pipeline it builds the code, persists the output to a branch called\ngh-pages and deploys the site to github pages. Both pipelines can be found on\n[github](https://github.com/Rotendahl/Start-Page-Generator/tree/master/.github/workflows)\nand the deployed code can be found at [rotendahl.dk/Start-Page-Generator/](https://rotendahl.dk/Start-Page-Generator/)\n\n\n[linksFile]: https://github.com/Rotendahl/StartPageGenerator/blob/master/links.txt\n[tab-groups]: https://support.apple.com/en-gb/guide/safari/ibrwa2d73908/mac\n[favorites]: https://github.com/Rotendahl/Start-Page-Generator/blob/a8a2dced57325b0f0084d7dc009570b501826ee0/links.txt\n[cabal]: https://www.haskell.org/cabal/\n[parsec]: https://hackage.haskell.org/package/parsec\n[bnf]: https://en.wikipedia.org/wiki/Backus–Naur_form\n[lexeme]: https://hackage.haskell.org/package/parsec-3.1.3/docs/Text-Parsec-Token.html#v%3alexeme\n[quickcheck]: https://hackage.haskell.org/package/QuickCheck\n[hunit]: https://hackage.haskell.org/package/HUnit\n[hspec]: https://hspec.github.io/\n\n[^1]: I'm not overengineering my grammer for my overengineered project.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","resource-path":["../../assets"],"toc":true,"number-sections":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.353","number-depth":3,"smooth-scroll":true,"theme":{"light":"litera","dark":"Cyborg"},"title-block-banner":true,"title":"Overengineering a start page","author":"Benjamin Rotendahl","date":"2023-05-13","date-modified":"2023-05-23","categories":["front-end","code","haskell"],"image":"https://github.com/Rotendahl/Start-Page-Generator/blob/gh-pages/example.png?raw=true","titlegraphic":"https://github.com/Rotendahl/Start-Page-Generator/blob/gh-pages/example.png?raw=true"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}